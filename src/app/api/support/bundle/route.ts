import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { buildSupportBundle, SupportBundleError } from "@/lib/support/bundle";
import { writeAuditLog } from "@/lib/audit-log";
import { requireOpsAccess } from "@/lib/rbac";
import { safeRequestUrl } from "@/lib/request-url";

export const dynamic = "force-dynamic";

type BundleOptions = {
  hostId?: string | null;
  includeRaw?: boolean;
  limit?: number;
  download?: boolean;
};

function parseBool(v: string | null): boolean {
  if (!v) return false;
  const t = v.trim().toLowerCase();
  return t === "1" || t === "true" || t === "yes";
}

function parseLimit(raw: string | null | undefined): number | undefined {
  if (!raw) return undefined;
  const n = Number(raw);
  if (!Number.isFinite(n)) return undefined;
  return Math.max(20, Math.min(500, Math.trunc(n)));
}

async function buildAndRespond(req: Request, opts: BundleOptions) {
  const access = await requireOpsAccess();
  if (!access.ok) {
    await writeAuditLog({
      req,
      action: "support.bundle.denied",
      detail: `status=${access.status} role=${access.role ?? "unknown"} email=${access.email ?? "unknown"}`,
      meta: {
        route: "/api/support/bundle",
        status: access.status,
        requiredRole: "ops",
        email: access.email ?? null,
        role: access.role ?? null,
      },
    });
    return NextResponse.json({ ok: false, error: access.error }, { status: access.status });
  }

  const user = await prisma.user.findUnique({
    where: { id: access.identity.userId },
    select: { id: true, email: true },
  });
  if (!user) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

  try {
    const bundle = await buildSupportBundle({
      userId: user.id,
      hostId: opts.hostId ?? null,
      includeRaw: opts.includeRaw,
      limit: opts.limit,
    });

    await writeAuditLog({
      req,
      userId: user.id,
      hostId: opts.hostId ?? null,
      action: "support.bundle.generated",
      detail: `Support bundle generated by ${user.email}`,
      meta: {
        route: "/api/support/bundle",
        hostId: opts.hostId ?? null,
        includeRaw: Boolean(opts.includeRaw),
        limit: opts.limit ?? null,
        download: Boolean(opts.download),
      },
    });

    const res = NextResponse.json(bundle);
    res.headers.set("Cache-Control", "no-store, max-age=0");
    if (opts.download) {
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      res.headers.set(
        "Content-Disposition",
        `attachment; filename="vps-sentry-support-${stamp}.json"`
      );
    }
    return res;
  } catch (err: unknown) {
    if (err instanceof SupportBundleError) {
      return NextResponse.json({ ok: false, error: err.message }, { status: err.status });
    }
    const message = err instanceof Error ? err.message : String(err);
    return NextResponse.json({ ok: false, error: message }, { status: 500 });
  }
}

export async function GET(req: Request) {
  const url = safeRequestUrl(req);
  const opts: BundleOptions = {
    hostId: url.searchParams.get("hostId"),
    includeRaw: parseBool(url.searchParams.get("includeRaw")),
    limit: parseLimit(url.searchParams.get("limit")),
    download: parseBool(url.searchParams.get("download")),
  };
  return buildAndRespond(req, opts);
}

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const opts: BundleOptions = {
    hostId: typeof body?.hostId === "string" ? body.hostId.trim() : undefined,
    includeRaw: Boolean(body?.includeRaw),
    limit: parseLimit(
      typeof body?.limit === "number" ? String(body.limit) : typeof body?.limit === "string" ? body.limit : null
    ),
    download: Boolean(body?.download),
  };
  return buildAndRespond(req, opts);
}
