// /var/www/vps-sentry-web/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_DATABASE_URL")
}

//
// ---------- Enums ----------
//
enum Plan {
  FREE
  BASIC
  PRO
}

enum UserRole {
  owner
  admin
  ops
  viewer
}

enum BreachSeverity {
  info
  warn
  critical
}

enum BreachState {
  open
  fixed
  ignored
}

enum NotifyKind {
  EMAIL
  WEBHOOK
}

enum RemediationState {
  queued
  running
  succeeded
  failed
  canceled
}

enum IncidentSeverity {
  critical
  high
  medium
}

enum IncidentState {
  open
  acknowledged
  resolved
  closed
}

enum PostmortemStatus {
  not_started
  draft
  published
  waived
}

//
// ---------- Models ----------
//
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  role          UserRole  @default(viewer)
  emailVerified DateTime?
  image         String?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt

  // ---- Billing / entitlements ----
  stripeCustomerId    String?  @unique
  plan                Plan     @default(FREE)
  hostLimit           Int      @default(1)

  // Mirror "current subscription state" for quick reads in the app
  subscriptionStatus  String?
  subscriptionId      String?  @unique
  currentPeriodEnd    DateTime?

  // Relations (NextAuth)
  accounts      Account[]
  sessions      Session[]

  // One-to-one (our internal subscription row)
  subscription  Subscription?

  // ---- VPS Sentry v1.0 ----
  hosts                  Host[]
  notificationEndpoints   NotificationEndpoint[]
  remediationRuns         RemediationRun[]        @relation("RemediationRequestedBy")
  auditLogs               AuditLog[]
  incidentCreatedRuns     IncidentWorkflowRun[]   @relation("IncidentCreatedBy")
  incidentAssignedRuns    IncidentWorkflowRun[]   @relation("IncidentAssignee")
  incidentAcknowledgedRuns IncidentWorkflowRun[]  @relation("IncidentAcknowledgedBy")
  incidentResolvedRuns    IncidentWorkflowRun[]   @relation("IncidentResolvedBy")
  incidentClosedRuns      IncidentWorkflowRun[]   @relation("IncidentClosedBy")
  incidentEvents          IncidentWorkflowEvent[] @relation("IncidentEventActor")
}

model Subscription {
  id               String   @id @default(cuid())
  userId           String   @unique

  stripeCustomerId String
  stripeSubId      String   @unique
  status           String
  priceId          String
  currentPeriodEnd DateTime?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

//
// -------- VPS Sentry v1.0 core --------
//
model Host {
  id           String   @id @default(cuid())
  userId       String
  name         String

  // optional human slug (nice URLs); keep unique per-user
  slug         String?

  // agent / heartbeat
  lastSeenAt   DateTime?
  agentVersion String?

  enabled      Boolean  @default(true)

  // optional metadata stored as JSON text (sqlite-safe)
  metaJson     String?

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  apiKeys              HostApiKey[]
  snapshots            HostSnapshot[]
  breaches             Breach[]
  remediationRuns      RemediationRun[]
  notificationEvents   NotificationEvent[]
  auditLogs            AuditLog[]
  incidentRuns         IncidentWorkflowRun[]

  @@index([userId])
  @@unique([userId, slug])
}

model HostApiKey {
  id         String   @id @default(cuid())
  hostId     String

  // store only a hash of the token; never store plaintext
  tokenHash  String   @unique

  // short prefix for display like "vs_8f3a..."
  prefix     String
  version    Int      @default(1)
  label      String?
  // JSON array for scopes, e.g. ["host.status.write","host.status.read"]
  scopeJson  String?

  createdAt  DateTime @default(now())
  lastUsedAt DateTime?
  revokedAt  DateTime?
  revokedReason String?
  expiresAt  DateTime?
  rotatedFromKeyId String?

  host       Host     @relation(fields: [hostId], references: [id], onDelete: Cascade)

  @@index([hostId])
  @@index([hostId, revokedAt])
  @@index([hostId, version])
  @@index([hostId, expiresAt])
}

model HostSnapshot {
  id        String   @id @default(cuid())
  hostId    String

  // timestamp inside the payload (agent time). Store as DateTime for timeline queries.
  ts        DateTime

  // envelope bits (all stored as JSON text)
  statusJson String
  lastJson   String?
  diffJson   String?

  // fast fields for UI / queries
  ok               Boolean @default(true)
  alertsCount      Int     @default(0)
  publicPortsCount Int     @default(0)

  createdAt DateTime @default(now())

  host      Host     @relation(fields: [hostId], references: [id], onDelete: Cascade)

  @@index([hostId, ts])
  @@index([hostId, createdAt])
}

model Breach {
  id          String         @id @default(cuid())
  hostId      String

  code        String?
  title       String
  detail      String?

  severity    BreachSeverity @default(warn)
  state       BreachState    @default(open)

  openedTs    DateTime
  fixedTs     DateTime?

  // JSON text evidence (forward compatible)
  evidenceJson String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  host        Host     @relation(fields: [hostId], references: [id], onDelete: Cascade)

  @@index([hostId, state])
  @@index([hostId, openedTs])
  @@index([hostId, updatedAt])
}

model NotificationEndpoint {
  id        String     @id @default(cuid())
  userId    String

  kind      NotifyKind
  // EMAIL: address, WEBHOOK: url (we can validate at runtime)
  target    String

  enabled   Boolean    @default(true)

  // optional JSON text (headers, templates, etc.)
  metaJson  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  events    NotificationEvent[]

  @@index([userId])
  @@index([userId, kind])
}

model NotificationEvent {
  id          String   @id @default(cuid())
  hostId      String?
  endpointId  String?

  // what happened
  eventType   String   // e.g. "breach.open", "alerts.present", "ship.failed"
  title       String
  detail      String?

  // delivery result
  deliveredOk Boolean?
  deliveredTs DateTime?
  error       String?

  // raw payload we attempted to ship (json text)
  payloadJson String?

  createdAt   DateTime @default(now())

  host        Host?                 @relation(fields: [hostId], references: [id], onDelete: SetNull)
  endpoint    NotificationEndpoint? @relation(fields: [endpointId], references: [id], onDelete: SetNull)

  @@index([hostId, createdAt])
  @@index([endpointId, createdAt])
  @@index([eventType, createdAt])
}

model RemediationAction {
  id              String   @id @default(cuid())
  key             String   @unique // e.g. "nginx.reload", "ufw.enable", "ship.test"
  title           String
  description     String?
  enabled         Boolean  @default(true)

  // optional JSON text schema for params
  paramsSchemaJson String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  runs            RemediationRun[]
}

model RemediationRun {
  id                String           @id @default(cuid())
  hostId            String
  actionId          String
  requestedByUserId String?

  state             RemediationState @default(queued)

  requestedAt       DateTime @default(now())
  startedAt         DateTime?
  finishedAt        DateTime?

  // JSON text (inputs/outputs)
  paramsJson        String?
  output            String?
  error             String?

  host              Host              @relation(fields: [hostId], references: [id], onDelete: Cascade)
  action            RemediationAction @relation(fields: [actionId], references: [id], onDelete: Cascade)
  requestedBy       User?             @relation("RemediationRequestedBy", fields: [requestedByUserId], references: [id], onDelete: SetNull)

  @@index([hostId, requestedAt])
  @@index([hostId, state])
  @@index([actionId, requestedAt])
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  hostId    String?

  action    String   // e.g. "host.create", "host.key.rotate", "remediate.run"
  detail    String?
  metaJson  String?

  ip        String?
  userAgent String?

  createdAt DateTime @default(now())

  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  host      Host?    @relation(fields: [hostId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([hostId, createdAt])
  @@index([action, createdAt])
}

model IncidentWorkflowRun {
  id                  String           @id @default(cuid())
  workflowId          String
  workflowTitle       String?
  title               String
  summary             String?
  severity            IncidentSeverity @default(medium)
  state               IncidentState    @default(open)
  triggerSignal       String?

  hostId              String?
  createdByUserId     String?
  assigneeUserId      String?
  assigneeEmail       String?
  acknowledgedAt      DateTime?
  acknowledgedByUserId String?
  ackDueAt            DateTime?
  escalatedAt         DateTime?
  escalationCount     Int              @default(0)
  nextEscalationAt    DateTime?
  resolvedAt          DateTime?
  resolvedByUserId    String?
  closedAt            DateTime?
  closedByUserId      String?

  postmortemStatus         PostmortemStatus @default(not_started)
  postmortemSummary        String?
  postmortemImpact         String?
  postmortemRootCause      String?
  postmortemActionItemsJson String?
  postmortemPublishedAt    DateTime?

  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  host                Host?            @relation(fields: [hostId], references: [id], onDelete: SetNull)
  createdByUser       User?            @relation("IncidentCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  assigneeUser        User?            @relation("IncidentAssignee", fields: [assigneeUserId], references: [id], onDelete: SetNull)
  acknowledgedByUser  User?            @relation("IncidentAcknowledgedBy", fields: [acknowledgedByUserId], references: [id], onDelete: SetNull)
  resolvedByUser      User?            @relation("IncidentResolvedBy", fields: [resolvedByUserId], references: [id], onDelete: SetNull)
  closedByUser        User?            @relation("IncidentClosedBy", fields: [closedByUserId], references: [id], onDelete: SetNull)
  events              IncidentWorkflowEvent[]

  @@index([state, createdAt])
  @@index([workflowId, createdAt])
  @@index([hostId, createdAt])
  @@index([ackDueAt, state])
  @@index([nextEscalationAt, state])
  @@index([createdByUserId, createdAt])
  @@index([assigneeUserId, state])
}

model IncidentWorkflowEvent {
  id          String              @id @default(cuid())
  incidentId  String
  type        String
  stepId      String?
  message     String
  eventTs     DateTime            @default(now())
  actorUserId String?
  metaJson    String?

  incident    IncidentWorkflowRun @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  actorUser   User?               @relation("IncidentEventActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([incidentId, eventTs])
  @@index([type, eventTs])
  @@index([actorUserId, eventTs])
}

//
// NextAuth / Auth.js tables
//
model Account {
  id                String  @id @default(cuid())
  userId            String

  type              String
  provider          String
  providerAccountId String

  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
